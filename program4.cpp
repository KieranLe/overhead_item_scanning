// Name: Kieran Le

//    Copyright 2018 Christopher D. McMurrough
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
/***********************************************************************************************************************
* @file display_pcd.cpp
* @brief load and display PCD data files
*
* Simple example of loading and displaying PCD files, can be used as a template for processing saved data
*
* @author Christopher D. McMurrough
**********************************************************************************************************************/

#include "CloudVisualizer.h"

#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/io/pcd_io.h>
#include <pcl/io/ply_io.h>
#include <pcl/common/time.h>

#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/kdtree/io.h>
#include <pcl/segmentation/euclidean_cluster_comparator.h>
#include <pcl/segmentation/extract_clusters.h>

#include <pcl/sample_consensus/model_types.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/sac_model_plane.h>
#include <pcl/segmentation/sac_segmentation.h>

#define NUM_COMMAND_ARGS 1

using namespace std;

// function prototypes
void pointPickingCallback(const pcl::visualization::PointPickingEvent& event, void* cookie);
void keyboardCallback(const pcl::visualization::KeyboardEvent &event, void* viewer_void);

/***********************************************************************************************************************
* @brief callback function for handling a point picking event
* @param[in] event handle generated by the visualization window
* @param[in] cookie user data passed by the event
* @author Christoper D. McMurrough
**********************************************************************************************************************/
void pointPickingCallback(const pcl::visualization::PointPickingEvent& event, void* cookie)
{
    static int pickCount = 0;
    static pcl::PointXYZRGBA lastPoint;

    pcl::PointXYZRGBA p;
    event.getPoint(p.x, p.y, p.z);

    cout << "POINT CLICKED: " << p.x << " " << p.y << " " << p.z << endl;

    // if we have picked a point previously, compute the distance
    if(pickCount % 2 == 1)
    {
        double d = std::sqrt((p.x - lastPoint.x) * (p.x - lastPoint.x) + (p.y - lastPoint.y) * (p.y - lastPoint.y) + (p.z - lastPoint.z) * (p.z - lastPoint.z));
        cout << "DISTANCE BETWEEN THE POINTS: " << d << endl;
    }

    // update the last point and pick count
    lastPoint.x = p.x;
    lastPoint.y = p.y;
    lastPoint.z = p.z;
    pickCount++;
}

/***********************************************************************************************************************
* @brief callback function for handling a keypress event
* @param[in] event handle generated by the visualization window
* @param[in] viewer_void user data passed by the event
* @author Christoper D. McMurrough
**********************************************************************************************************************/
void keyboardCallback(const pcl::visualization::KeyboardEvent &event, void* viewer_void)
{
    // handle key down events
    if(event.keyDown())
    {
        // handle any keys of interest
        switch(event.getKeyCode())
        {
            case 'a':
                cout << "KEYPRESS DETECTED: '" << event.getKeySym() << "'" << endl;
                break;
            default:
                break;
        }
    }
}

/***********************************************************************************************************************
* @brief Opens a point cloud file
*
* Opens a point cloud file in either PCD or PLY format
*
* @param[out] cloudOut pointer to opened point cloud
* @param[in] filename path and name of input file
* @return false if an error occurred while opening file
* @author Christopher D. McMurrough
**********************************************************************************************************************/
bool openCloud(pcl::PointCloud<pcl::PointXYZRGBA>::Ptr &cloudOut, const char* fileName)
{
    // convert the file name to string
    std::string fileNameStr(fileName);

    // handle various file types
    std::string fileExtension = fileNameStr.substr(fileNameStr.find_last_of(".") + 1);
    if(fileExtension.compare("pcd") == 0)
    {
        // attempt to open the file
        if(pcl::io::loadPCDFile<pcl::PointXYZRGBA>(fileNameStr, *cloudOut) == -1)
        {
            PCL_ERROR("error while attempting to read pcd file: %s \n", fileNameStr.c_str());
            return false;
        }
        else
        {
            return true;
        }
    }
    else if(fileExtension.compare("ply") == 0)
    {
        // attempt to open the file
        if(pcl::io::loadPLYFile<pcl::PointXYZRGBA>(fileNameStr, *cloudOut) == -1)
        {
            PCL_ERROR("error while attempting to read pcl file: %s \n", fileNameStr.c_str());
            return false;
        }
        else
        {
            return true;
        }
    }
    else
    {
        PCL_ERROR("error while attempting to read unsupported file: %s \n", fileNameStr.c_str());
        return false;
    }
}

void segmentPlane(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr &cloudIn, pcl::PointIndices::Ptr &inliers, double distanceThreshold, int maxIterations)
{
    // store the model coefficients
    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);

    // Create the segmentation object for the planar model and set the parameters
    pcl::SACSegmentation<pcl::PointXYZRGBA> seg;
    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setMaxIterations(maxIterations);
    seg.setDistanceThreshold(distanceThreshold);

    // Segment the largest planar component from the remaining cloud
    seg.setInputCloud(cloudIn);
    seg.segment(*inliers, *coefficients);
}

void segmentSphere(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr &cloudIn, pcl::PointIndices::Ptr &inliers, double distanceThreshold, int maxIterations)
{
    // store the model coefficients
    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);

    // Create the segmentation object for the planar model and set the parameters
    pcl::SACSegmentation<pcl::PointXYZRGBA> seg;
    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_SPHERE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setMaxIterations(maxIterations);
    seg.setDistanceThreshold(distanceThreshold);


    // Segment the largest planar component from the remaining cloud
    seg.setInputCloud(cloudIn);
    seg.segment(*inliers, *coefficients);
}


/***********************************************************************************************************************
* @brief program entry point
* @param[in] argc number of command line arguments
* @param[in] argv string array of command line arguments
* @returnS return code (0 for normal termination)
* @author Christoper D. McMurrough
**********************************************************************************************************************/
int main(int argc, char** argv)
{
    // validate and parse the command line arguments
    if(argc != NUM_COMMAND_ARGS + 1)
    {
        std::printf("USAGE: %s <file_name>\n", argv[0]);
        return 0;
    }

    // parse the command line arguments
    char* fileName = argv[1];

    // create a stop watch for measuring time
    pcl::StopWatch watch;

    // initialize the cloud viewer
    CloudVisualizer CV("Rendering Window");

    // start timing the processing step
    watch.reset();

    // open the point cloud
    pcl::PointCloud<pcl::PointXYZRGBA>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGBA>);
    openCloud(cloud, fileName);

//-------------------------------------------------------------------------------------------

    // downsample the cloud using a voxel grid filter
    const float voxelSize = 0.01;
    pcl::PointCloud<pcl::PointXYZRGBA>::Ptr cloudFiltered(new pcl::PointCloud<pcl::PointXYZRGBA>);
    pcl::VoxelGrid<pcl::PointXYZRGBA> voxFilter;
    voxFilter.setInputCloud(cloud);
    voxFilter.setLeafSize(static_cast<float>(voxelSize), static_cast<float>(voxelSize), static_cast<float>(voxelSize));
    voxFilter.filter(*cloudFiltered);


    // segment a plane
    // This will detect the plane behind the table top
    // We will filter this plane out
    const float distanceThreshold = 0.0254;
    const int maxIterations = 5000;
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
    segmentPlane(cloudFiltered, inliers, distanceThreshold, maxIterations);


    // Cut off values that are outside of (-0.8, 0,0) zone and in "z" direction with [PassThrough].
    // This will cut off everything behind of the the tabletop. 
    // The result after running this will be: tabletop + everything on the table
    pcl::PassThrough<pcl::PointXYZRGBA> ptfilter;
    ptfilter.setInputCloud(cloudFiltered);
    ptfilter.setFilterFieldName("z");
    ptfilter.setFilterLimits(-0.8, 0.0); 
    ptfilter.filter(*cloudFiltered);


    // This will detect the surface of the tabletop
    segmentPlane(cloudFiltered, inliers, distanceThreshold, maxIterations);


    // Color the tabletop with blue
    for(int i = 0; i < inliers->indices.size(); i++)
    {
        int index = inliers->indices.at(i);
        cloudFiltered->points.at(index).r = 0;
        cloudFiltered->points.at(index).g = 255;
        cloudFiltered->points.at(index).b = 255;
    }

    // After detect the tabletop, we will have to extract that out of the cloud
    // New PointCloud to store the new cloud without tabletop surface
    pcl::PointCloud<pcl::PointXYZRGBA>::Ptr cloud_NoTableTop(new pcl::PointCloud<pcl::PointXYZRGBA>);
    pcl::ExtractIndices<pcl::PointXYZRGBA> extract;
    extract.setInputCloud(cloudFiltered);
    extract.setIndices(inliers);
    extract.setNegative(true);
    extract.filter( *cloud_NoTableTop );


    // create the vector of indices lists (each element contains a list of imultiple indices)
    const float clusterDistance = 0.02;
    int minClusterSize = 50;
    int maxClusterSize = 100000;
    std::vector<pcl::PointIndices> clusterIndices;


    // Creating the KdTree object for the search method of the extraction
    pcl::search::KdTree<pcl::PointXYZRGBA>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZRGBA>);
    tree->setInputCloud(cloud_NoTableTop);


    // Create the euclidian cluster extraction object
    pcl::EuclideanClusterExtraction<pcl::PointXYZRGBA> ec;
    ec.setClusterTolerance(clusterDistance);
    ec.setMinClusterSize(minClusterSize);
    ec.setMaxClusterSize(maxClusterSize);
    ec.setSearchMethod(tree);
    ec.setInputCloud(cloud_NoTableTop);

    // perform the clustering
    ec.extract(clusterIndices);


    /*
    [individualCluster] will be used to store indices of each cluster. 
    [x] and [y] will be used to help us access to one cluster at a time.
    [sphere] to help identify if the currect cluster is a sphere or not. If not, it is a box.
    [count] is used to access a specific cluster.
    [countBox] stores the number of box. 
    [countSphere] stores the number of sphere.
    */
    pcl::PointCloud<pcl::PointXYZRGBA>::Ptr individualCluster (new pcl::PointCloud<pcl::PointXYZRGBA>);
    int numClusters = clusterIndices.size();
    int x = 0, y = -3;
    bool sphere = false;
    int count = 0;
    int countBox = 0, countSphere = 0;
    while( numClusters != 0 )
    {
        // Iterate over one cluster at a time
        for(std::vector<pcl::PointIndices>::const_iterator it = clusterIndices.begin() + x; it!= clusterIndices.end() + y; ++it)
        {   
            // Copy all indices into a new point cloud
            for( const auto& idx: it->indices )
            {
                individualCluster->push_back((*cloud_NoTableTop)[idx]);            
            }
            individualCluster->width = individualCluster->size();
            individualCluster->height = 1;
            individualCluster->is_dense = true;

            // Increment of x and y by 1 to move to the next cluster
            x = x + 1;
            y = y + 1;
            break;
        }

        // Check to see if the cluster is a sphere
        segmentSphere(individualCluster, inliers, distanceThreshold, maxIterations);
        
        // If indices size is less than 1700, then it is a box
        if( inliers->indices.size() < 1700 )
        {
            // Run [segmentPlane]
            segmentPlane(individualCluster, inliers, distanceThreshold, maxIterations);
            sphere = false;
            countBox++;
        }
        else
        {
            // Set sphere to true if it is a sphere
            sphere = true;
            countSphere++;
        }


        if( sphere == false )
        {
            // Color box with green
            for(int j = 0; j < clusterIndices.at(count).indices.size(); j++)
            {
                cloud_NoTableTop->points.at(clusterIndices.at(count).indices.at(j)).r = 0;
                cloud_NoTableTop->points.at(clusterIndices.at(count).indices.at(j)).g = 255;
                cloud_NoTableTop->points.at(clusterIndices.at(count).indices.at(j)).b = 0;
            }
        }
        else
        {
            for(int j = 0; j < clusterIndices.at(count).indices.size(); j++)
            {
                //Color sphere with red
                cloud_NoTableTop->points.at(clusterIndices.at(count).indices.at(j)).r = 255;
                cloud_NoTableTop->points.at(clusterIndices.at(count).indices.at(j)).g = 0;
                cloud_NoTableTop->points.at(clusterIndices.at(count).indices.at(j)).b = 0;
            }
        }

        count++;
        numClusters--;
    }

    // Print to console the count for box and sphere
    std::cout<< "BOX    COUNT = " << countBox    << std::endl;
    std::cout<< "SPHERE COUNT = " << countSphere << std::endl;


    // Create a new point cloud that will store the concatenation of 2 point clouds.
    pcl::PointCloud<pcl::PointXYZRGBA>::Ptr finalCloud(new pcl::PointCloud<pcl::PointXYZRGBA>);
    // Concatenate 2 clouds together to get a final complete cloud.
    // [cloudFiltered] stores the tabletop surface.
    // [cloud_NoTableTop]  stores all the object on the tabletop surface.
    *finalCloud = (*cloudFiltered) +(*cloud_NoTableTop);


    // Write output of point cloud data to PCD file
    pcl::io::savePCDFileASCII("output.pcd", *finalCloud);

//-------------------------------------------------------------------------------------------

    // get the elapsed time
    double elapsedTime = watch.getTimeSeconds();
    cout << elapsedTime << " seconds passed " << std::endl;

    // render the scene
    CV.addCloud(finalCloud); //new change
    CV.addCoordinateFrame(finalCloud->sensor_origin_, finalCloud->sensor_orientation_);
 

    // register mouse and keyboard event callbacks
    CV.registerPointPickingCallback(pointPickingCallback, finalCloud); 
    CV.registerKeyboardCallback(keyboardCallback);

    // enter visualization loop
    while(CV.isRunning())
    {
        CV.spin(100);
    }

    // exit program
    return 0;
}
